# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Log-likelihood and gradient for multinomial logit model
#'
#' @param theta K + J - 1 or K + J vector with model parameters
#' @param X sum(M) x K design matrix with covariates. Stacks M\[i] x K matrices for individual i.
#' @param alt_idx sum(M) x 1 vector with indices of alternatives within each choice set; 1-based indexing
#' @param choice_idx N x 1 vector with indices of chosen alternatives; 1-based indexing relative to X; 0 is used if include_outside_option=True
#' @param M N x 1 vector with number of alternatives for each individual
#' @param weights N x 1 vector with weights for each observation
#' @param use_asc whether to use alternative-specific constants
#' @param include_outside_option whether to include outside option normalized to 0 (if so, the outside option is not included in the data)
#' @return List with loglikelihood and gradient evaluated at input arguments
#' @export
mnl_loglik_gradient_parallel <- function(theta, X, alt_idx, choice_idx, M, weights, use_asc = TRUE, include_outside_option = FALSE) {
    .Call(`_choicer_mnl_loglik_gradient_parallel`, theta, X, alt_idx, choice_idx, M, weights, use_asc, include_outside_option)
}

#' Numerical Hessian of the log-likelihood via finite differences
#'
#' @param theta K + J - 1 or K + J vector with model parameters
#' @param X sum(M) x K design matrix with covariates. Stacks M\[i] x K matrices for individual i.
#' @param alt_idx sum(M) x 1 vector with indices of alternatives within each choice set; 1-based indexing
#' @param choice_idx N x 1 vector with indices of chosen alternatives; 1-based indexing relative to X; 0 is used if include_outside_option=True
#' @param M N x 1 vector with number of alternatives for each individual
#' @param weights N x 1 vector with weights for each observation
#' @param use_asc whether to use alternative-specific constants
#' @param include_outside_option whether to include outside option normalized to 0 (if so, the outside option is not included in the data)
#' @param eps finite difference step size
#' @return Hessian evaluated at input arguments
#' @export
mnl_loglik_numeric_hessian <- function(theta, X, alt_idx, choice_idx, M, weights, use_asc = TRUE, include_outside_option = TRUE, eps = 1e-6) {
    .Call(`_choicer_mnl_loglik_numeric_hessian`, theta, X, alt_idx, choice_idx, M, weights, use_asc, include_outside_option, eps)
}

#' Prediction of choice probabilities and utilities based on fitted model
#'
#' @param theta K + J - 1 or K + J vector with model parameters
#' @param X sum(M) x K design matrix with covariates. Stacks M\[i] x K matrices for individual i.
#' @param alt_idx sum(M) x 1 vector with indices of alternatives within each choice set; 1-based indexing
#' @param M N x 1 vector with number of alternatives for each individual
#' @param use_asc whether to use alternative-specific constants
#' @param include_outside_option whether to include outside option normalized to 0 (if so, the outside option is not included in the data)
#' @return List with choice probability and utility for each choice situation evaluated at input arguments
#' @export
mnl_predict <- function(theta, X, alt_idx, M, use_asc = TRUE, include_outside_option = FALSE) {
    .Call(`_choicer_mnl_predict`, theta, X, alt_idx, M, use_asc, include_outside_option)
}

#' Prediction of market shares based on fitted model
#'
#' @param theta K + J - 1 or K + J vector with model parameters
#' @param X sum(M) x K design matrix with covariates. Stacks M\[i] x K matrices for individual i.
#' @param alt_idx sum(M) x 1 vector with indices of alternatives within each choice set; 1-based indexing
#' @param M N x 1 vector with number of alternatives for each individual
#' @param weights N x 1 vector with weights for each observation
#' @param use_asc whether to use alternative-specific constants
#' @param include_outside_option whether to include outside option normalized to 0 (if so, the outside option is not included in the data)
#' @return vector with predicted market shares for each alternative
#' @export
mnl_predict_shares <- function(theta, X, alt_idx, M, weights, use_asc = TRUE, include_outside_option = FALSE) {
    .Call(`_choicer_mnl_predict_shares`, theta, X, alt_idx, M, weights, use_asc, include_outside_option)
}

#' BLP95 contraction mapping to find delta given target shares
#'
#' @param delta J x 1 vector with initial guess for deltas (ASCs)
#' @param target_shares J x 1 vector with target shares for each alternative
#' @param X sum(M) x K design matrix with covariates. M\[i] x K matrix for individual i
#' @param beta K x 1 vector with model parameters
#' @param alt_idx sum(M) x 1 vector with indices of alternatives within each choice set; 1-based indexing
#' @param M N x 1 vector with number of alternatives for each individual
#' @param weights N x 1 vector with weights for each observation
#' @param include_outside_option whether to include outside option normalized to 0 (if so, the outside option is not included in the data)
#' @param tol convergence tolerance
#' @param max_iter maximum number of iterations
#' @return vector with contraction's delta (ASCs) output
#' @export
blp_contraction <- function(delta, target_shares, X, beta, alt_idx, M, weights, include_outside_option = FALSE, tol = 1e-8, max_iter = 1000L) {
    .Call(`_choicer_blp_contraction`, delta, target_shares, X, beta, alt_idx, M, weights, include_outside_option, tol, max_iter)
}

#' Hessian matrix for multinomial logit model
#'
#' @param theta K + J - 1 or K + J vector with model parameters
#' @param X sum(M) x K design matrix with covariates. Stacks M\[i] x K matrices for individual i.
#' @param alt_idx sum(M) x 1 vector with indices of alternatives within each choice set; 1-based indexing
#' @param choice_idx N x 1 vector with indices of chosen alternatives; 1-based indexing relative to X; 0 is used if include_outside_option=True
#' @param M N x 1 vector with number of alternatives for each individual
#' @param weights N x 1 vector with weights for each observation
#' @param use_asc whether to use alternative-specific constants
#' @param include_outside_option whether to include outside option normalized to 0 (if so, the outside option is not included in the data)
#' @return Hessian matrix of the negative log-likelihood
#' @export
mnl_loglik_hessian_parallel <- function(theta, X, alt_idx, choice_idx, M, weights, use_asc = TRUE, include_outside_option = FALSE) {
    .Call(`_choicer_mnl_loglik_hessian_parallel`, theta, X, alt_idx, choice_idx, M, weights, use_asc, include_outside_option)
}

build_L_mat <- function(L_params, K_w, rc_correlation) {
    .Call(`_choicer_build_L_mat`, L_params, K_w, rc_correlation)
}

#' Reconstruct variance matrix L from L_params
#'
#' @param L_params flattened choleski decomposition version of the random coefficient parameters matrix
#' @param K_w dimension of the random coefficient parameter (symmetric) matrix
#' @param rc_correlation whether random coefficients are correlated
#' @return matrix equal to LL', where L is the choleski decomposition of random coefficient matrix
#' @export
build_var_mat <- function(L_params, K_w, rc_correlation) {
    .Call(`_choicer_build_var_mat`, L_params, K_w, rc_correlation)
}

#' Log-likelihood and gradient for Mixed Logit
#'
#' @param theta vector collecting model parameters (beta, L, delta (ASCs))
#' @param X design matrix for covariates with fixed coefficients; sum(M_i) x K_x
#' @param W design matrix for covariates with random coefficients; sum(M_i) x K_w or J x K_w
#' @param alt_idx sum(M) x 1 vector with indices of alternatives within each choice set; 1-based indexing
#' @param choice_idx N x 1 vector with indices of chosen alternatives; 1-based indexing relative to X; 0 is used if include_outside_option=True
#' @param M N x 1 vector with number of alternatives for each individual
#' @param weights N x 1 vector with weights for each observation
#' @param eta_draws Array with choice situation draws; K_w x S x N 
#' @param rc_correlation whether random coefficients should be correlated
#' @param use_asc whether to use alternative-specific constants
#' @param include_outside_option whether to include outside option normalized to 0 (if so, the outside option is not included in the data)
#' @return List with loglikelihood and gradient evaluated at input arguments
#' @export
mxl_loglik_gradient_parallel <- function(theta, X, W, alt_idx, choice_idx, M, weights, eta_draws, rc_correlation = TRUE, use_asc = TRUE, include_outside_option = FALSE) {
    .Call(`_choicer_mxl_loglik_gradient_parallel`, theta, X, W, alt_idx, choice_idx, M, weights, eta_draws, rc_correlation, use_asc, include_outside_option)
}

#' Numerical Hessian of the log-likelihood via finite differences for mixed logit
#'
#' @param theta vector collecting model parameters (beta, L, delta (ASCs))
#' @param X design matrix for covariates with fixed coefficients; sum(M_i) x K_x
#' @param W design matrix for covariates with random coefficients; sum(M_i) x K_w or J x K_w
#' @param alt_idx sum(M) x 1 vector with indices of alternatives within each choice set; 1-based indexing
#' @param choice_idx N x 1 vector with indices of chosen alternatives; 1-based indexing relative to X; 0 is used if include_outside_option=True
#' @param M N x 1 vector with number of alternatives for each individual
#' @param weights N x 1 vector with weights for each observation
#' @param eta_draws Array with choice situation draws; K_w x S x N 
#' @param rc_correlation whether random coefficients should be correlated
#' @param use_asc whether to use alternative-specific constants
#' @param include_outside_option whether to include outside option normalized to 0 (if so, the outside option is not included in the data)
#' @param eps numerical tolerance
#' @return List with loglikelihood and gradient evaluated at input arguments
#' @export
mxl_loglik_numeric_hessian <- function(theta, X, W, alt_idx, choice_idx, M, weights, eta_draws, rc_correlation = TRUE, use_asc = TRUE, include_outside_option = FALSE, eps = 1e-6) {
    .Call(`_choicer_mxl_loglik_numeric_hessian`, theta, X, W, alt_idx, choice_idx, M, weights, eta_draws, rc_correlation, use_asc, include_outside_option, eps)
}

#' Utility to compute analytical Jacobian of random coefficient matrix transformed by vech (dVech(Sigma) / dTheta)
#'
#' @param L_params flattened choleski decomposition version of the random coefficient parameters matrix
#' @param K_w dimension of the random coefficient parameter (symmetric) matrix
#' @param rc_correlation whether random coefficients are correlated
#' @return Jacobian (dVech(Sigma) / dTheta)
#' @export
jacobian_vech_Sigma <- function(L_params, K_w, rc_correlation = TRUE) {
    .Call(`_choicer_jacobian_vech_Sigma`, L_params, K_w, rc_correlation)
}

#' Analytical Hessian of the log-likelihood
#'
#' @param theta vector collecting model parameters (beta, L, delta (ASCs))
#' @param X design matrix for covariates with fixed coefficients; sum(M_i) x K_x
#' @param W design matrix for covariates with random coefficients; sum(M_i) x K_w or J x K_w
#' @param alt_idx sum(M) x 1 vector with indices of alternatives within each choice set; 1-based indexing
#' @param choice_idx N x 1 vector with indices of chosen alternatives; 1-based indexing relative to X; 0 is used if include_outside_option=True
#' @param M N x 1 vector with number of alternatives for each individual
#' @param weights N x 1 vector with weights for each observation
#' @param eta_draws Array with choice situation draws; K_w x S x N 
#' @param rc_correlation whether random coefficients should be correlated
#' @param use_asc whether to use alternative-specific constants
#' @param include_outside_option whether to include outside option normalized to 0 (if so, the outside option is not included in the data)
#' @return Hessian evaluated at input arguments
#' @export
mxl_hessian_parallel <- function(theta, X, W, alt_idx, choice_idx, M, weights, eta_draws, rc_correlation = TRUE, use_asc = TRUE, include_outside_option = FALSE) {
    .Call(`_choicer_mxl_hessian_parallel`, theta, X, W, alt_idx, choice_idx, M, weights, eta_draws, rc_correlation, use_asc, include_outside_option)
}

#' Log-likelihood and gradient for Nested Logit model
#'
#' @param theta (K + n_non_singleton_nests + n_delta) vector with model parameters.
#'        Order: [beta (K), lambda (n_non_singleton_nests), delta (n_delta)]
#' @param X sum(M) x K design matrix with covariates.
#' @param alt_idx sum(M) x 1 vector with indices of alternatives; 1-based indexing.
#' @param choice_idx N x 1 vector with indices of chosen alternatives; 0 for outside option,
#'        1-based index relative to rows in X_i otherwise.
#' @param nest_idx J x 1 vector with indices of nests for each alternative; 1-based indexing (1 to n_nests).
#' @param M N x 1 vector with number of alternatives for each individual.
#' @param weights N x 1 vector with weights for each observation.
#' @param use_asc whether to use alternative-specific constants.
#' @param include_outside_option whether to include outside option normalized to V=0, lambda=1.
#' @return List with loglikelihood and gradient evaluated at input arguments
#' @export
nl_loglik_gradient_parallel <- function(theta, X, alt_idx, choice_idx, nest_idx, M, weights, use_asc = TRUE, include_outside_option = FALSE) {
    .Call(`_choicer_nl_loglik_gradient_parallel`, theta, X, alt_idx, choice_idx, nest_idx, M, weights, use_asc, include_outside_option)
}

#' Numerical Hessian of the log-likelihood via finite differences
#'
#' @param theta (K + n_delta + n_nests) vector with model parameters.
#'        Order: [beta (K), delta (n_delta), lambda (n_nests)]
#' @param X sum(M) x K design matrix with covariates.
#' @param alt_idx sum(M) x 1 vector with indices of alternatives; 1-based indexing.
#' @param choice_idx N x 1 vector with indices of chosen alternatives; 0 for outside option,
#'        1-based index relative to rows in X_i otherwise.
#' @param nest_idx J x 1 vector with indices of nests for each alternative; 1-based indexing (1 to n_nests).
#' @param M N x 1 vector with number of alternatives for each individual.
#' @param weights N x 1 vector with weights for each observation.
#' @param use_asc whether to use alternative-specific constants.
#' @param include_outside_option whether to include outside option normalized to V=0, lambda=1.
#' @param eps finite difference step size
#' @return Hessian evaluated at input arguments
#' @export
nl_loglik_numeric_hessian <- function(theta, X, alt_idx, choice_idx, nest_idx, M, weights, use_asc = TRUE, include_outside_option = FALSE, eps = 1e-6) {
    .Call(`_choicer_nl_loglik_numeric_hessian`, theta, X, alt_idx, choice_idx, nest_idx, M, weights, use_asc, include_outside_option, eps)
}

get_num_threads <- function() {
    invisible(.Call(`_choicer_get_num_threads`))
}

set_num_threads <- function(n_threads) {
    invisible(.Call(`_choicer_set_num_threads`, n_threads))
}

