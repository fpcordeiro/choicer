# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Log-likelihood and gradient for multinomial logit model
#'
#' Computes the log-likelihood and its gradient for the Multinomial Logit model using OpenMP for parallelization.
#' Allows for inclusion of alternative-specific constants, outside option, and observation weights.
#'
#' @param theta K + J - 1 or K + J vector with model parameters
#' @param X sum(M) x K design matrix with covariates. Stacks M\[i] x K matrices for individual i.
#' @param alt_idx sum(M) x 1 vector with indices of alternatives within each choice set; 1-based indexing
#' @param choice_idx N x 1 vector with indices of chosen alternatives; 1-based indexing relative to X; 0 is used if include_outside_option=True
#' @param M N x 1 vector with number of alternatives for each individual
#' @param weights N x 1 vector with weights for each observation
#' @param use_asc whether to use alternative-specific constants
#' @param include_outside_option whether to include outside option normalized to 0 (if so, the outside option is not included in the data)
#' @return List with loglikelihood and gradient evaluated at input arguments
#' @export
mnl_loglik_gradient_parallel <- function(theta, X, alt_idx, choice_idx, M, weights, use_asc = TRUE, include_outside_option = FALSE) {
    .Call(`_choicer_mnl_loglik_gradient_parallel`, theta, X, alt_idx, choice_idx, M, weights, use_asc, include_outside_option)
}

#' Numerical Hessian of the log-likelihood via finite differences
#'
#' @param theta K + J - 1 or K + J vector with model parameters
#' @param X sum(M) x K design matrix with covariates. Stacks M\[i] x K matrices for individual i.
#' @param alt_idx sum(M) x 1 vector with indices of alternatives within each choice set; 1-based indexing
#' @param choice_idx N x 1 vector with indices of chosen alternatives; 1-based indexing relative to X; 0 is used if include_outside_option=True
#' @param M N x 1 vector with number of alternatives for each individual
#' @param weights N x 1 vector with weights for each observation
#' @param use_asc whether to use alternative-specific constants
#' @param include_outside_option whether to include outside option normalized to 0 (if so, the outside option is not included in the data)
#' @param eps finite difference step size
#' @return Hessian evaluated at input arguments
#' @export
mnl_loglik_numeric_hessian <- function(theta, X, alt_idx, choice_idx, M, weights, use_asc = TRUE, include_outside_option = TRUE, eps = 1e-6) {
    .Call(`_choicer_mnl_loglik_numeric_hessian`, theta, X, alt_idx, choice_idx, M, weights, use_asc, include_outside_option, eps)
}

#' Prediction of choice probabilities and utilities based on fitted model
#'
#' @param theta K + J - 1 or K + J vector with model parameters
#' @param X sum(M) x K design matrix with covariates. Stacks M\[i] x K matrices for individual i.
#' @param alt_idx sum(M) x 1 vector with indices of alternatives within each choice set; 1-based indexing
#' @param M N x 1 vector with number of alternatives for each individual
#' @param use_asc whether to use alternative-specific constants
#' @param include_outside_option whether to include outside option normalized to 0 (if so, the outside option is not included in the data)
#' @return List with choice probability and utility for each choice situation evaluated at input arguments
#' @export
mnl_predict <- function(theta, X, alt_idx, M, use_asc = TRUE, include_outside_option = FALSE) {
    .Call(`_choicer_mnl_predict`, theta, X, alt_idx, M, use_asc, include_outside_option)
}

#' Prediction of market shares based on fitted model
#'
#' @param theta K + J - 1 or K + J vector with model parameters
#' @param X sum(M) x K design matrix with covariates. Stacks M\[i] x K matrices for individual i.
#' @param alt_idx sum(M) x 1 vector with indices of alternatives within each choice set; 1-based indexing
#' @param M N x 1 vector with number of alternatives for each individual
#' @param weights N x 1 vector with weights for each observation
#' @param use_asc whether to use alternative-specific constants
#' @param include_outside_option whether to include outside option normalized to 0 (if so, the outside option is not included in the data)
#' @return vector with predicted market shares for each alternative
#' @export
mnl_predict_shares <- function(theta, X, alt_idx, M, weights, use_asc = TRUE, include_outside_option = FALSE) {
    .Call(`_choicer_mnl_predict_shares`, theta, X, alt_idx, M, weights, use_asc, include_outside_option)
}

#' BLP95 contraction mapping to find delta given target shares
#'
#' @param delta J x 1 vector with initial guess for deltas (ASCs)
#' @param target_shares J x 1 vector with target shares for each alternative
#' @param X sum(M) x K design matrix with covariates. M\[i] x K matrix for individual i
#' @param beta K x 1 vector with model parameters
#' @param alt_idx sum(M) x 1 vector with indices of alternatives within each choice set; 1-based indexing
#' @param M N x 1 vector with number of alternatives for each individual
#' @param weights N x 1 vector with weights for each observation
#' @param include_outside_option whether to include outside option normalized to 0 (if so, the outside option is not included in the data)
#' @param tol convergence tolerance
#' @param max_iter maximum number of iterations
#' @return vector with contraction's delta (ASCs) output
#' @export
blp_contraction <- function(delta, target_shares, X, beta, alt_idx, M, weights, include_outside_option = FALSE, tol = 1e-8, max_iter = 1000L) {
    .Call(`_choicer_blp_contraction`, delta, target_shares, X, beta, alt_idx, M, weights, include_outside_option, tol, max_iter)
}

#' Hessian matrix for multinomial logit model
#'
#' @param theta K + J - 1 or K + J vector with model parameters
#' @param X sum(M) x K design matrix with covariates. Stacks M\[i] x K matrices for individual i.
#' @param alt_idx sum(M) x 1 vector with indices of alternatives within each choice set; 1-based indexing
#' @param choice_idx N x 1 vector with indices of chosen alternatives; 1-based indexing relative to X; 0 is used if include_outside_option=True
#' @param M N x 1 vector with number of alternatives for each individual
#' @param weights N x 1 vector with weights for each observation
#' @param use_asc whether to use alternative-specific constants
#' @param include_outside_option whether to include outside option normalized to 0 (if so, the outside option is not included in the data)
#' @return Hessian matrix of the negative log-likelihood
#' @export
mnl_loglik_hessian_parallel <- function(theta, X, alt_idx, choice_idx, M, weights, use_asc = TRUE, include_outside_option = FALSE) {
    .Call(`_choicer_mnl_loglik_hessian_parallel`, theta, X, alt_idx, choice_idx, M, weights, use_asc, include_outside_option)
}

#' Compute aggregate elasticities for MNL model
#'
#' Computes the aggregate elasticity matrix (weighted average of individual
#' elasticities) for the Multinomial Logit model.
#'
#' @param theta K + J - 1 or K + J vector with model parameters
#' @param X sum(M) x K design matrix with covariates.
#' @param alt_idx sum(M) x 1 vector with indices of alternatives; 1-based indexing
#' @param choice_idx N x 1 vector (kept for API consistency, but not used)
#' @param M N x 1 vector with number of alternatives for each individual
#' @param weights N x 1 vector with weights for each observation
#' @param elast_var_idx 1-based index of the column in X for which to compute the elasticity
#' @param use_asc whether to use alternative-specific constants
#' @param include_outside_option whether to include outside option
#' @return J x J matrix of aggregate elasticities
#' @export
mnl_elasticities_parallel <- function(theta, X, alt_idx, choice_idx, M, weights, elast_var_idx, use_asc = TRUE, include_outside_option = FALSE) {
    .Call(`_choicer_mnl_elasticities_parallel`, theta, X, alt_idx, choice_idx, M, weights, elast_var_idx, use_asc, include_outside_option)
}

build_L_mat <- function(L_params, K_w, rc_correlation) {
    .Call(`_choicer_build_L_mat`, L_params, K_w, rc_correlation)
}

#' Reconstruct variance matrix L from L_params
#'
#' @param L_params flattened choleski decomposition version of the random coefficient parameters matrix
#' @param K_w dimension of the random coefficient parameter (symmetric) matrix
#' @param rc_correlation whether random coefficients are correlated
#' @return matrix equal to LL', where L is the choleski decomposition of random coefficient matrix
#' @export
build_var_mat <- function(L_params, K_w, rc_correlation) {
    .Call(`_choicer_build_var_mat`, L_params, K_w, rc_correlation)
}

#' Log-likelihood and gradient for Mixed Logit
#'
#' Computes the log-likelihood and its gradient for the Mixed Logit model using
#' OpenMP for parallelization. Allows for inclusion of alternative-specific
#' constants, outside option, observation weights, correlated random coefficients.
#'
#' @param theta vector collecting model parameters (beta, mu, L, delta (ASCs))
#' @param X design matrix for covariates with fixed coefficients; sum(M_i) x K_x
#' @param W design matrix for covariates with random coefficients; sum(M_i) x K_w or J x K_w
#' @param alt_idx sum(M) x 1 vector with indices of alternatives within each choice set; 1-based indexing
#' @param choice_idx N x 1 vector with indices of chosen alternatives; 1-based indexing relative to X; 0 is used if include_outside_option=True
#' @param M N x 1 vector with number of alternatives for each individual
#' @param weights N x 1 vector with weights for each observation
#' @param eta_draws Array with choice situation draws; K_w x S x N
#' @param rc_dist K_w x 1 integer vector indicating distribution of random coefficients: 0 = normal, 1 = log-normal
#' @param rc_correlation whether random coefficients should be correlated
#' @param rc_mean whether to estimate means for random coefficients. If so, mean parameters (mu) should be included in theta after beta parameters.
#' @param use_asc whether to use alternative-specific constants. If so, parameters should be included in theta after beta and L (and mu, if applicable).
#' @param include_outside_option whether to include outside option normalized to 0 (if so, the outside option is not included in the data)
#' @return List with loglikelihood and gradient evaluated at input arguments
#' @note For log-normal random coefficients (rc_dist=1) with rc_mean=TRUE,
#'   the distribution is a shifted log-normal: beta_k = exp(mu_k) + exp(L_k * eta),
#'   where exp(mu_k) shifts the location and exp(L_k * eta) ~ LogNormal(0, sigma_k^2).
#'   This differs from the textbook parameterization exp(mu_k + L_k * eta).
#' @export
mxl_loglik_gradient_parallel <- function(theta, X, W, alt_idx, choice_idx, M, weights, eta_draws, rc_dist, rc_correlation = TRUE, rc_mean = FALSE, use_asc = TRUE, include_outside_option = FALSE) {
    .Call(`_choicer_mxl_loglik_gradient_parallel`, theta, X, W, alt_idx, choice_idx, M, weights, eta_draws, rc_dist, rc_correlation, rc_mean, use_asc, include_outside_option)
}

#' Numerical Hessian of the log-likelihood via finite differences for mixed logit
#'
#' @param theta vector collecting model parameters (beta, mu, L, delta (ASCs))
#' @param X design matrix for covariates with fixed coefficients; sum(M_i) x K_x
#' @param W design matrix for covariates with random coefficients; sum(M_i) x K_w or J x K_w
#' @param alt_idx sum(M) x 1 vector with indices of alternatives within each choice set; 1-based indexing
#' @param choice_idx N x 1 vector with indices of chosen alternatives; 1-based indexing relative to X; 0 is used if include_outside_option=True
#' @param M N x 1 vector with number of alternatives for each individual
#' @param weights N x 1 vector with weights for each observation
#' @param eta_draws Array with choice situation draws; K_w x S x N
#' @param rc_dist K_w x 1 integer vector indicating distribution of random coefficients: 0 = normal, 1 = log-normal
#' @param rc_correlation whether random coefficients should be correlated
#' @param rc_mean whether to estimate means for random coefficients. If so, mean parameters (mu) should be included in theta after beta parameters.
#' @param use_asc whether to use alternative-specific constants. If so, parameters should be included in theta after beta and L (and mu, if applicable).
#' @param include_outside_option whether to include outside option normalized to 0 (if so, the outside option is not included in the data)
#' @param eps numerical tolerance
#' @return List with loglikelihood and gradient evaluated at input arguments
#' @export
mxl_loglik_numeric_hessian <- function(theta, X, W, alt_idx, choice_idx, M, weights, eta_draws, rc_dist, rc_correlation = TRUE, rc_mean = FALSE, use_asc = TRUE, include_outside_option = FALSE, eps = 1e-6) {
    .Call(`_choicer_mxl_loglik_numeric_hessian`, theta, X, W, alt_idx, choice_idx, M, weights, eta_draws, rc_dist, rc_correlation, rc_mean, use_asc, include_outside_option, eps)
}

#' Utility to compute analytical Jacobian of random coefficient matrix transformed by vech (dVech(Sigma) / dTheta)
#'
#' @param L_params flattened choleski decomposition version of the random coefficient parameters matrix
#' @param K_w dimension of the random coefficient parameter (symmetric) matrix
#' @param rc_correlation whether random coefficients are correlated
#' @return Jacobian (dVech(Sigma) / dTheta)
#' @export
jacobian_vech_Sigma <- function(L_params, K_w, rc_correlation = TRUE) {
    .Call(`_choicer_jacobian_vech_Sigma`, L_params, K_w, rc_correlation)
}

#' Analytical Hessian of the log-likelihood v2
#'
#' Computes the Hessian of the log-likelihood for the Mixed Logit model using
#' OpenMP for parallelization. Mirrors the parameters of mxl_loglik_gradient_parallel.
#'
#' @param theta vector collecting model parameters (beta, mu, L, delta (ASCs))
#' @param X design matrix for covariates with fixed coefficients; sum(M_i) x K_x
#' @param W design matrix for covariates with random coefficients; sum(M_i) x K_w or J x K_w
#' @param alt_idx sum(M) x 1 vector with indices of alternatives within each choice set; 1-based indexing
#' @param choice_idx N x 1 vector with indices of chosen alternatives; 1-based indexing relative to X; 0 is used if include_outside_option=True
#' @param M N x 1 vector with number of alternatives for each individual
#' @param weights N x 1 vector with weights for each observation
#' @param eta_draws Array with choice situation draws; K_w x S x N
#' @param rc_dist K_w x 1 integer vector indicating distribution of random coefficients: 0 = normal, 1 = log-normal
#' @param rc_correlation whether random coefficients should be correlated
#' @param rc_mean whether to estimate means for random coefficients.
#' @param use_asc whether to use alternative-specific constants.
#' @param include_outside_option whether to include outside option normalized to 0 (if so, the outside option is not included in the data)
#' @return Hessian evaluated at input arguments
#' @note For log-normal random coefficients (rc_dist=1) with rc_mean=TRUE,
#'   the distribution is a shifted log-normal: beta_k = exp(mu_k) + exp(L_k * eta),
#'   where exp(mu_k) shifts the location and exp(L_k * eta) ~ LogNormal(0, sigma_k^2).
#'   This differs from the textbook parameterization exp(mu_k + L_k * eta).
#' @export
mxl_hessian_parallel <- function(theta, X, W, alt_idx, choice_idx, M, weights, eta_draws, rc_dist, rc_correlation = TRUE, rc_mean = FALSE, use_asc = TRUE, include_outside_option = FALSE) {
    .Call(`_choicer_mxl_hessian_parallel`, theta, X, W, alt_idx, choice_idx, M, weights, eta_draws, rc_dist, rc_correlation, rc_mean, use_asc, include_outside_option)
}

#' BLP contraction mapping for mixed logit
#'
#' Finds the ASC (delta) parameters such that predicted market shares
#' match target shares, using the contraction mapping of Berry, Levinsohn,
#' and Pakes (1995).
#'
#' @param delta J-1 or J vector with initial guess for deltas (ASCs)
#' @param target_shares J vector with target market shares
#' @param X design matrix for fixed coefficients; sum(M_i) x K_x
#' @param W design matrix for random coefficients; sum(M_i) x K_w or J x K_w
#' @param beta K_x vector with fixed coefficients
#' @param mu K_w vector with mean parameters (raw, will be transformed if log-normal)
#' @param L_params Cholesky parameters vector
#' @param alt_idx sum(M) x 1 vector with indices of alternatives; 1-based indexing
#' @param M N x 1 vector with number of alternatives for each individual
#' @param weights N x 1 vector with weights for each observation
#' @param eta_draws Array with draws; K_w x S x N
#' @param rc_dist K_w vector indicating distribution (0=normal, 1=log-normal)
#' @param rc_correlation whether random coefficients are correlated
#' @param rc_mean whether mu parameters represent means (TRUE) or are zero (FALSE)
#' @param include_outside_option whether outside option is included
#' @param tol convergence tolerance (default 1e-8)
#' @param max_iter maximum iterations (default 1000)
#' @return vector with converged delta (ASC) values
#' @export
mxl_blp_contraction <- function(delta, target_shares, X, W, beta, mu, L_params, alt_idx, M, weights, eta_draws, rc_dist, rc_correlation = TRUE, rc_mean = FALSE, include_outside_option = FALSE, tol = 1e-8, max_iter = 1000L) {
    .Call(`_choicer_mxl_blp_contraction`, delta, target_shares, X, W, beta, mu, L_params, alt_idx, M, weights, eta_draws, rc_dist, rc_correlation, rc_mean, include_outside_option, tol, max_iter)
}

#' Compute aggregate elasticities for mixed logit model
#'
#' Computes the aggregate elasticity matrix (weighted average of individual
#' elasticities) for the Mixed Logit model. The elasticity E(i,j) represents
#' the percentage change in the probability of choosing alternative i when
#' the attribute of alternative j changes by 1%.
#'
#' @param theta parameter vector (beta, [mu], L, delta)
#' @param X design matrix for fixed coefficients; sum(M_i) x K_x
#' @param W design matrix for random coefficients; sum(M_i) x K_w or J x K_w
#' @param alt_idx sum(M) x 1 vector with indices of alternatives; 1-based indexing
#' @param choice_idx N x 1 vector (kept for API consistency, not used)
#' @param M N x 1 vector with number of alternatives for each individual
#' @param weights N x 1 vector with weights for each observation
#' @param eta_draws Array with draws; K_w x S x N
#' @param rc_dist K_w vector indicating distribution (0=normal, 1=log-normal)
#' @param elast_var_idx 1-based index of the variable for elasticity computation
#' @param is_random_coef TRUE if variable is in W (random coef), FALSE if in X (fixed coef)
#' @param rc_correlation whether random coefficients are correlated
#' @param rc_mean whether mu parameters are estimated
#' @param use_asc whether ASCs are included
#' @param include_outside_option whether outside option is included
#' @return J x J matrix of aggregate elasticities
#' @export
mxl_elasticities_parallel <- function(theta, X, W, alt_idx, choice_idx, M, weights, eta_draws, rc_dist, elast_var_idx, is_random_coef, rc_correlation = TRUE, rc_mean = FALSE, use_asc = TRUE, include_outside_option = FALSE) {
    .Call(`_choicer_mxl_elasticities_parallel`, theta, X, W, alt_idx, choice_idx, M, weights, eta_draws, rc_dist, elast_var_idx, is_random_coef, rc_correlation, rc_mean, use_asc, include_outside_option)
}

#' Log-likelihood and gradient for Nested Logit model
#'
#' Computes the log-likelihood and its gradient for the Nested Logit model using OpenMP for parallelization.
#' Especially handles singleton nests by fixing their lambda parameters to 1. Only non-singleton nests have a inclusive value coefficient estimated in theta.
#'
#' @param theta (K + n_non_singleton_nests + n_delta) vector with model parameters.
#'        Order: `[beta (K), lambda (n_non_singleton_nests), delta (n_delta)]`
#' @param X sum(M) x K design matrix with covariates.
#' @param alt_idx sum(M) x 1 vector with indices of alternatives; 1-based indexing.
#' @param choice_idx N x 1 vector with indices of chosen alternatives; 0 for outside option,
#'        1-based index relative to rows in X_i otherwise.
#' @param nest_idx J x 1 vector with indices of nests for each alternative; 1-based indexing (1 to n_nests).
#' @param M N x 1 vector with number of alternatives for each individual.
#' @param weights N x 1 vector with weights for each observation.
#' @param use_asc whether to use alternative-specific constants.
#' @param include_outside_option whether to include outside option normalized to V=0, lambda=1.
#' @return List with loglikelihood and gradient evaluated at input arguments
#' @export
nl_loglik_gradient_parallel <- function(theta, X, alt_idx, choice_idx, nest_idx, M, weights, use_asc = TRUE, include_outside_option = FALSE) {
    .Call(`_choicer_nl_loglik_gradient_parallel`, theta, X, alt_idx, choice_idx, nest_idx, M, weights, use_asc, include_outside_option)
}

#' Numerical Hessian of the log-likelihood via finite differences
#'
#' @param theta (K + n_delta + n_nests) vector with model parameters.
#'        Order: `[beta (K), delta (n_delta), lambda (n_nests)]`
#' @param X sum(M) x K design matrix with covariates.
#' @param alt_idx sum(M) x 1 vector with indices of alternatives; 1-based indexing.
#' @param choice_idx N x 1 vector with indices of chosen alternatives; 0 for outside option,
#'        1-based index relative to rows in X_i otherwise.
#' @param nest_idx J x 1 vector with indices of nests for each alternative; 1-based indexing (1 to n_nests).
#' @param M N x 1 vector with number of alternatives for each individual.
#' @param weights N x 1 vector with weights for each observation.
#' @param use_asc whether to use alternative-specific constants.
#' @param include_outside_option whether to include outside option normalized to V=0, lambda=1.
#' @param eps finite difference step size
#' @return Hessian evaluated at input arguments
#' @export
nl_loglik_numeric_hessian <- function(theta, X, alt_idx, choice_idx, nest_idx, M, weights, use_asc = TRUE, include_outside_option = FALSE, eps = 1e-6) {
    .Call(`_choicer_nl_loglik_numeric_hessian`, theta, X, alt_idx, choice_idx, nest_idx, M, weights, use_asc, include_outside_option, eps)
}

get_num_threads <- function() {
    invisible(.Call(`_choicer_get_num_threads`))
}

set_num_threads <- function(n_threads) {
    invisible(.Call(`_choicer_set_num_threads`, n_threads))
}

